{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _parseInt from \"@babel/runtime-corejs2/core-js/parse-int\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport connectDB from '../../utils/connectDB';\nimport Product from '../../models/Product';\nexport default (async (req, res) => {\n  await connectDB();\n\n  switch (req.method) {\n    case 'GET':\n      await handleGet(req, res);\n      break;\n\n    case 'POST':\n      await handlePost(req, res);\n\n    default:\n      break;\n  }\n});\n\nasync function handleGet(req, res) {\n  let query; // Copy req.query\n\n  const reqQuery = _objectSpread({}, req.query); // Fields to exclude\n\n\n  const removeFields = ['select', 'sort', 'page', 'limit', 'keyword']; // Loop over removeFields and delete them from reqQuery\n\n  removeFields.forEach(param => delete reqQuery[param]);\n\n  if (req.query.keyword) {\n    reqQuery.keyword = req.query.keyword;\n  } // Create query string\n\n\n  let queryStr = _JSON$stringify(reqQuery); // Create operators ($gt, $gte, etc)\n\n\n  queryStr = queryStr.replace(/\\b(gt|gte|lt|lte|in)\\b/g, match => `$${match}`); // products = await Product.find({ $text: { $search: keyword } }).sort(sort);\n  // Finding resource\n\n  query = Product.find(JSON.parse(queryStr)); // Select Fields\n\n  if (req.query.select) {\n    const fields = req.query.select.split(',').join(' ');\n    query = query.select(fields);\n  } // Sort\n\n\n  if (req.query.sort) {\n    const sortBy = req.query.sort.split(',').join(' ');\n    query = query.sort(sortBy);\n  } else {\n    query = query.sort('-createdAt');\n  } // Pagination\n\n\n  const page = _parseInt(req.query.page, 10) || 1;\n  const limit = _parseInt(req.query.limit, 10) || 25;\n  const startIndex = (page - 1) * limit;\n  const endIndex = page * limit;\n  const totalProducts = await Product.countDocuments();\n  query = query.skip(startIndex).limit(limit); // Executing query\n\n  const products = await query;\n  res.status(200).json({\n    products,\n    totalProducts\n  });\n}\n\nasync function handlePost(req, res) {\n  const {\n    name,\n    price,\n    description,\n    imageURL,\n    category\n  } = req.body;\n\n  try {\n    const product = await new Product({\n      name,\n      price,\n      description,\n      imageURL,\n      category\n    }).save();\n    res.status(201).json({\n      success: true,\n      product\n    });\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('Error in creating product');\n  }\n}","map":{"version":3,"sources":["/home/russ/projects/dress-shop/pages/api/products.js"],"names":["connectDB","Product","req","res","method","handleGet","handlePost","query","reqQuery","removeFields","forEach","param","keyword","queryStr","replace","match","find","JSON","parse","select","fields","split","join","sort","sortBy","page","limit","startIndex","endIndex","totalProducts","countDocuments","skip","products","status","json","name","price","description","imageURL","category","body","product","save","success","error","console","send"],"mappings":"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","sourcesContent":["import connectDB from '../../utils/connectDB';\nimport Product from '../../models/Product';\n\nexport default async (req, res) => {\n  await connectDB();\n  switch (req.method) {\n    case 'GET':\n      await handleGet(req, res);\n      break;\n    case 'POST':\n      await handlePost(req, res);\n    default:\n      break;\n  }\n};\n\nasync function handleGet(req, res) {\n  let query;\n\n  // Copy req.query\n  const reqQuery = { ...req.query };\n\n  // Fields to exclude\n  const removeFields = ['select', 'sort', 'page', 'limit', 'keyword'];\n\n  // Loop over removeFields and delete them from reqQuery\n  removeFields.forEach(param => delete reqQuery[param]);\n\n  if (req.query.keyword) {\n    reqQuery.keyword = req.query.keyword;\n  }\n\n  // Create query string\n  let queryStr = JSON.stringify(reqQuery);\n\n  // Create operators ($gt, $gte, etc)\n  queryStr = queryStr.replace(/\\b(gt|gte|lt|lte|in)\\b/g, match => `$${match}`);\n\n  // products = await Product.find({ $text: { $search: keyword } }).sort(sort);\n\n  // Finding resource\n  query = Product.find(JSON.parse(queryStr));\n\n  // Select Fields\n  if (req.query.select) {\n    const fields = req.query.select.split(',').join(' ');\n    query = query.select(fields);\n  }\n\n  // Sort\n  if (req.query.sort) {\n    const sortBy = req.query.sort.split(',').join(' ');\n    query = query.sort(sortBy);\n  } else {\n    query = query.sort('-createdAt');\n  }\n\n  // Pagination\n  const page = parseInt(req.query.page, 10) || 1;\n  const limit = parseInt(req.query.limit, 10) || 25;\n  const startIndex = (page - 1) * limit;\n  const endIndex = page * limit;\n  const totalProducts = await Product.countDocuments();\n\n  query = query.skip(startIndex).limit(limit);\n\n  // Executing query\n  const products = await query;\n\n  res.status(200).json({ products, totalProducts });\n}\n\nasync function handlePost(req, res) {\n  const { name, price, description, imageURL, category } = req.body;\n  try {\n    const product = await new Product({\n      name,\n      price,\n      description,\n      imageURL,\n      category\n    }).save();\n    res.status(201).json({ success: true, product });\n  } catch (error) {\n    console.error(error);\n    res.status(500).send('Error in creating product');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}